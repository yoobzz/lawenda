<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Malowanie modelu lawendy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #1a1a1a; color: #eee; overflow: hidden; }
        #canvas-wrap { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #panel {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 10;
            background: rgba(0,0,0,0.75);
            padding: 12px 16px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        h2 { font-size: 14px; font-weight: 600; margin-bottom: 4px; }
        .row { display: flex; align-items: center; gap: 10px; }
        button {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }
        .btn-lawenda { background: #8a73c8; color: #fff; }
        .btn-stalk { background: #4b7341; color: #fff; }
        .btn-export { background: #333; color: #fff; border: 1px solid #555; }
        .btn-export:hover { background: #444; }
        input[type="file"] { display: none; }
        .file-label {
            display: inline-block;
            padding: 8px 14px;
            background: #333;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            border: 1px solid #555;
        }
        .file-label:hover { background: #444; }
        .brush { display: flex; align-items: center; gap: 8px; }
        .brush span { font-size: 12px; }
        .brush input { width: 80px; }
        .hint { font-size: 11px; color: #999; max-width: 220px; }
    </style>
</head>
<body>
    <div id="canvas-wrap"></div>
    <div id="panel">
        <h2>Malowanie lawendy</h2>
        <div class="row">
            <label class="file-label">Wybierz STL<input type="file" id="fileInput" accept=".stl"></label>
        </div>
        <div class="row">
            <button class="btn-lawenda" id="btnLawenda">Kwiat (lawenda)</button>
            <button class="btn-stalk" id="btnStalk">Łodyga (zielony)</button>
        </div>
        <div class="row brush">
            <span>Pędzel:</span>
            <input type="range" id="brushSize" min="1" max="50" value="15">
            <span id="brushVal">15</span>
        </div>
        <div class="row">
            <button class="btn-export" id="btnExport">Zapisz kolory (JSON)</button>
        </div>
        <p class="hint">Lewy przycisk: maluj. Prawy przycisk + przeciągnij: obracaj model. Zapisz kolory jako lawenda-colors.json.</p>
    </div>

    <script>
        (function() {
            const container = document.getElementById('canvas-wrap');
            let scene, camera, renderer, points, pointsGeometry;
            let positions = [];
            let colors = [];
            let currentColor = 0;
            let brushSize = 15;
            let isDrawing = false;
            let isOrbiting = false;
            let mouse = new THREE.Vector2();
            let raycaster = new THREE.Raycaster();
            let maxSprites = 12000;
            let targetPoints = 28000;
            let camRadius = 8, camTheta = 0.6, camPhi = 0.9;
            let orbitStartX = 0, orbitStartY = 0, orbitStartTheta = 0, orbitStartPhi = 0;

            const lavender = new THREE.Color(0x8a73c8);
            const green = new THREE.Color(0x4b7341);

            function parseSTL(arrayBuffer) {
                const vertices = [];
                const dv = new DataView(arrayBuffer);
                const header = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer.slice(0, 5)));
                const isASCII = header.toLowerCase() === 'solid';
                if (isASCII) {
                    const text = new TextDecoder('utf-8').decode(arrayBuffer);
                    const vertexRegex = /vertex\s+([\d\.\+\-eE]+)\s+([\d\.\+\-eE]+)\s+([\d\.\+\-eE]+)/g;
                    let match;
                    while ((match = vertexRegex.exec(text)) !== null) {
                        vertices.push(new THREE.Vector3(parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3])));
                    }
                } else {
                    const numTriangles = dv.getUint32(80, true);
                    let offset = 84;
                    for (let i = 0; i < numTriangles; i++) {
                        offset += 12;
                        for (let j = 0; j < 3; j++) {
                            vertices.push(new THREE.Vector3(dv.getFloat32(offset, true), dv.getFloat32(offset + 4, true), dv.getFloat32(offset + 8, true)));
                            offset += 12;
                        }
                        offset += 2;
                    }
                }
                const step = Math.max(1, Math.floor(vertices.length / targetPoints));
                const out = [];
                for (let i = 0; i < vertices.length; i += step) out.push(vertices[i].clone());
                return out;
            }

            function init() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                camera = new THREE.PerspectiveCamera(60, w / h, 0.1, 1000);
                updateCameraPosition();
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(w, h);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                window.addEventListener('resize', function() {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                });
            }

            function loadModel(pointCloud) {
                if (pointCloud.length === 0) return;
                const box = new THREE.Box3();
                pointCloud.forEach(function(v) { box.expandByPoint(v); });
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 5 / maxDim;

                positions = [];
                const step = Math.max(1, Math.floor(pointCloud.length / maxSprites));
                for (let i = 0; i < pointCloud.length; i += step) {
                    const v = pointCloud[i];
                    positions.push((v.x - center.x) * scale, (v.y - center.y) * scale, (v.z - center.z) * scale);
                }
                const n = positions.length / 3;
                colors = new Array(n).fill(0);

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const colorArray = new Float32Array(n * 3);
                for (let i = 0; i < n; i++) {
                    const c = colors[i] === 1 ? green : lavender;
                    colorArray[i * 3] = c.r;
                    colorArray[i * 3 + 1] = c.g;
                    colorArray[i * 3 + 2] = c.b;
                }
                geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

                if (points) scene.remove(points);
                const mat = new THREE.PointsMaterial({
                    size: 0.12,
                    vertexColors: true,
                    sizeAttenuation: true
                });
                points = new THREE.Points(geometry, mat);
                points.rotation.x = -Math.PI / 2;
                scene.add(points);
                pointsGeometry = geometry;
            }

            function updateCameraPosition() {
                camera.position.x = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
                camera.position.y = camRadius * Math.cos(camPhi);
                camera.position.z = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
                camera.lookAt(0, 0, 0);
                camera.updateMatrixWorld(true);
            }

            function updateColors() {
                if (!pointsGeometry || !pointsGeometry.attributes.color) return;
                const n = colors.length;
                const colorArray = pointsGeometry.attributes.color.array;
                for (let i = 0; i < n; i++) {
                    const c = colors[i] === 1 ? green : lavender;
                    colorArray[i * 3] = c.r;
                    colorArray[i * 3 + 1] = c.g;
                    colorArray[i * 3 + 2] = c.b;
                }
                pointsGeometry.attributes.color.needsUpdate = true;
            }

            function paint(ndx) {
                if (ndx < 0 || ndx >= colors.length) return;
                const n = colors.length;
                const posAttr = pointsGeometry.attributes.position;
                const x = posAttr.getX(ndx);
                const y = posAttr.getY(ndx);
                const z = posAttr.getZ(ndx);
                const brush2 = (brushSize * 0.015) * (brushSize * 0.015);
                for (let i = 0; i < n; i++) {
                    const dx = posAttr.getX(i) - x;
                    const dy = posAttr.getY(i) - y;
                    const dz = posAttr.getZ(i) - z;
                    if (dx * dx + dy * dy + dz * dz < brush2) colors[i] = currentColor;
                }
                updateColors();
            }

            function getClosestPointIndex() {
                if (!points) return -1;
                raycaster.setFromCamera(mouse, camera);
                raycaster.params.Points = raycaster.params.Points || {};
                raycaster.params.Points.threshold = 0.3;
                const hits = raycaster.intersectObject(points);
                return hits.length > 0 ? hits[0].index : -1;
            }

            function updateMouse(e) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }

            container.addEventListener('mousedown', function(e) {
                if (e.target.closest && e.target.closest('#panel')) return;
                updateMouse(e);
                if (e.button === 0 && pointsGeometry) {
                    const ndx = getClosestPointIndex();
                    if (ndx >= 0) {
                        isDrawing = true;
                        paint(ndx);
                    }
                } else if (e.button === 2) {
                    e.preventDefault();
                    isOrbiting = true;
                    orbitStartX = e.clientX;
                    orbitStartY = e.clientY;
                    orbitStartTheta = camTheta;
                    orbitStartPhi = camPhi;
                }
            });
            container.addEventListener('mousemove', function(e) {
                updateMouse(e);
                if (isDrawing && pointsGeometry) {
                    const ndx = getClosestPointIndex();
                    if (ndx >= 0) paint(ndx);
                } else if (isOrbiting) {
                    camTheta = orbitStartTheta + (e.clientX - orbitStartX) * 0.01;
                    camPhi = Math.max(0.2, Math.min(Math.PI - 0.2, orbitStartPhi + (e.clientY - orbitStartY) * 0.01));
                    updateCameraPosition();
                }
            });
            container.addEventListener('mouseup', function(e) {
                if (e.button === 0) isDrawing = false;
                if (e.button === 2) isOrbiting = false;
            });
            container.addEventListener('mouseleave', function() { isDrawing = false; isOrbiting = false; });
            container.addEventListener('contextmenu', function(e) { e.preventDefault(); });

            document.getElementById('btnLawenda').addEventListener('click', function() { currentColor = 0; });
            document.getElementById('btnStalk').addEventListener('click', function() { currentColor = 1; });
            document.getElementById('brushSize').addEventListener('input', function(e) {
                brushSize = +e.target.value;
                document.getElementById('brushVal').textContent = brushSize;
            });

            document.getElementById('btnExport').addEventListener('click', function() {
                if (colors.length === 0) {
                    alert('Załaduj najpierw model STL.');
                    return;
                }
                const json = JSON.stringify({ colors: colors });
                const a = document.createElement('a');
                a.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(json);
                a.download = 'lawenda-colors.json';
                a.click();
            });

            document.getElementById('fileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const r = new FileReader();
                r.onload = function() {
                    const pointCloud = parseSTL(r.result);
                    loadModel(pointCloud);
                };
                r.readAsArrayBuffer(file);
            });

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }

            init();
            animate();
        })();
    </script>
</body>
</html>
