<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>point cloud — ~||-_^+*.</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:slnt,wght@-10..0,100..900&display=swap" rel="stylesheet">
    
    <meta name="description" content="staś szpineta archiwum">
    <meta property="og:title" content="point cloud — ~||-_^+*.">
    <meta property="og:description" content="staś szpineta archiwum">
    <meta property="og:type" content="website">
    <meta property="og:locale" content="pl_PL">
    <meta property="og:url" content="https://szpineta.pl/pointcloud.html">
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #1a1a1a;
            overflow: hidden;
            touch-action: none;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffffff;
        }

        .back-button {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background: transparent;
            border: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            color: #000000;
            opacity: 0.4;
            cursor: pointer;
            padding: 6px 8px;
            z-index: 110;
            transition: opacity 0.3s ease;
            text-decoration: none;
        }

        .back-button:hover {
            opacity: 0.8;
        }

        .nav-to-poems {
            position: fixed;
            top: 1rem;
            right: 1rem;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            color: #000000;
            opacity: 0.4;
            cursor: pointer;
            padding: 6px 8px;
            z-index: 110;
            transition: opacity 0.3s ease;
            text-decoration: none;
        }
        .nav-to-poems:hover {
            opacity: 0.8;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            color: #666;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .loading.show {
            opacity: 1;
        }

        .info {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            color: #999;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }

        .navigation {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 1rem;
            z-index: 100;
            align-items: center;
        }

        .nav-arrow {
            width: 40px;
            height: 40px;
            border: 2px solid #000000;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 16px;
            color: #000000;
            position: relative;
            overflow: hidden;
            border-radius: 50%;
        }

        .nav-arrow::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: #000000;
            transform: translate(-50%, -50%);
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1), height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: -1;
        }

        .nav-arrow:hover::before {
            width: 100%;
            height: 100%;
        }

        .nav-arrow:hover {
            color: #ffffff;
            transform: scale(1.08);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .nav-arrow:active {
            transform: scale(0.95);
        }

        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .nav-arrow:disabled:hover {
            background: transparent;
            color: #000000;
            transform: none;
            box-shadow: none;
        }

        .nav-arrow:disabled::before {
            display: none;
        }

        .nav-counter {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            color: #000000;
            padding: 0 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .nav-counter.updating {
            transform: scale(1.1);
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">~||-_^+*.</a>
    <a href="poems.html" class="nav-to-poems">wiersze</a>
    <div id="canvas-container"></div>
    <div class="loading" id="loading">Ładowanie...</div>
    <div class="info">Przeciągnij, aby obracać • Scroll, aby przybliżyć</div>
    <div class="navigation" id="navigation" style="display: none;">
        <button class="nav-arrow" id="prevBtn">‹</button>
        <div class="nav-counter" id="navCounter">1 / 1</div>
        <button class="nav-arrow" id="nextBtn">›</button>
    </div>

    <script>
        // Kolor lawendy (jeden odcień – wszystkie znaczki lawendowe)
        const lavenderColor = 0x8a73c8; // rgb(138, 115, 200) – wyraźna lawenda
        
        // Symbole do użycia
        const symbols = ['_', '-', '~', '"', '|', ',', '*', '^', ':', ';', '.', '+', '=', '`', "'", '!'];
        
        // Cache tekstur – jeden na symbol (żeby nie tworzyć tysięcy tekstur)
        const textureCache = {};
        function getSymbolTexture(symbol) {
            if (!textureCache[symbol]) {
                const size = 128;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const context = canvas.getContext('2d');
                context.clearRect(0, 0, size, size);
                context.imageSmoothingEnabled = false;
                context.fillStyle = 'rgba(138, 115, 200, 0.92)';
                context.font = '600 64px Inter, system-ui, sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(symbol, size / 2, size / 2);
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                textureCache[symbol] = texture;
            }
            return textureCache[symbol];
        }
        
        // Funkcja do generowania losowego symbolu
        function getRandomSymbol() {
            return symbols[Math.floor(Math.random() * symbols.length)];
        }
        
        let scene, camera, renderer, points, controls;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        let zoom = 1;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let sprites = [];
        let loadedModels = [];
        let currentModelIndex = 0;
        let raycaster = null;
        let mouse = new THREE.Vector2();
        let hoveredSprite = null;
        let animStart = typeof performance !== 'undefined' ? performance.now() : Date.now();
        let frameCount = 0;

        // Inicjalizacja sceny
        function init() {
            const container = document.getElementById('canvas-container');
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Scena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // Kamera
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Raycaster dla interakcji z myszką
            raycaster = new THREE.Raycaster();

            // Światło (dla lepszego efektu wizualnego)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Event listeners
            setupEventListeners();

            // Animacja
            animate();
        }

        // Parser STL do point cloud
        function parseSTLToPointCloud(arrayBuffer) {
            const vertices = [];
            const dataView = new DataView(arrayBuffer);
            
            // Sprawdź czy to ASCII STL (pierwsze 5 bajtów to "solid")
            const header = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer.slice(0, 5)));
            const isASCII = header.toLowerCase() === 'solid';
            
            if (isASCII) {
                // ASCII STL
                const text = new TextDecoder('utf-8').decode(arrayBuffer);
                const vertexRegex = /vertex\s+([\d\.\+\-eE]+)\s+([\d\.\+\-eE]+)\s+([\d\.\+\-eE]+)/g;
                let match;
                
                while ((match = vertexRegex.exec(text)) !== null) {
                    const x = parseFloat(match[1]);
                    const y = parseFloat(match[2]);
                    const z = parseFloat(match[3]);
                    vertices.push(new THREE.Vector3(x, y, z));
                }
            } else {
                // Binary STL
                const numTriangles = dataView.getUint32(80, true);
                let offset = 84;
                
                for (let i = 0; i < numTriangles; i++) {
                    // Skip normal (12 bytes: 3 floats)
                    offset += 12;
                    
                    // Read 3 vertices (each 12 bytes: 3 floats)
                    for (let j = 0; j < 3; j++) {
                        const x = dataView.getFloat32(offset, true);
                        offset += 4;
                        const y = dataView.getFloat32(offset, true);
                        offset += 4;
                        const z = dataView.getFloat32(offset, true);
                        offset += 4;
                        vertices.push(new THREE.Vector3(x, y, z));
                    }
                    
                    // Skip attribute byte count (2 bytes)
                    offset += 2;
                }
            }
            
            const targetPoints = 22000;
            const sparseFactor = Math.max(1, Math.floor(vertices.length / targetPoints));
            const points = [];
            
            for (let i = 0; i < vertices.length; i += sparseFactor) {
                points.push(vertices[i]);
            }
            
            return points;
        }

        // Załaduj i wyświetl STL
        function loadSTL(file) {
            const loading = document.getElementById('loading');
            loading.classList.add('show');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const stlData = e.target.result;
                    const pointCloud = parseSTLToPointCloud(stlData);
                    
                    // Oblicz centrum i skalę (jeszcze większy model)
                    const box = new THREE.Box3();
                    pointCloud.forEach(v => box.expandByPoint(v));
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 5.5 / maxDim; // Jeszcze większy model
                    
                    // Przesuń do centrum i przeskaluj
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(pointCloud.length * 3);
                    pointCloud.forEach((v, i) => {
                        const x = (v.x - center.x) * scale;
                        const y = (v.y - center.y) * scale;
                        const z = (v.z - center.z) * scale;
                        positions[i * 3] = x;
                        positions[i * 3 + 1] = y;
                        positions[i * 3 + 2] = z;
                    });
                    
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    // Usuń poprzednie
                    if (sprites.length > 0) {
                        sprites.forEach(sprite => scene.remove(sprite));
                        sprites = [];
                    }
                    if (points) {
                        scene.remove(points);
                        points = null;
                    }
                    
                    const positionsArray = geometry.attributes.position.array;
                    const spriteSize = 0.058;
                    
                    const maxSprites = 10000;
                    const step = Math.max(1, Math.floor(positionsArray.length / 3 / maxSprites));
                    
                    points = new THREE.Group();
                    
                    for (let i = 0; i < positionsArray.length; i += step * 3) {
                        const x = positionsArray[i];
                        const y = positionsArray[i + 1];
                        const z = positionsArray[i + 2];
                        
                        const symbol = getRandomSymbol();
                        const texture = getSymbolTexture(symbol);
                        
                        const spriteMaterial = new THREE.SpriteMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0.8,
                            depthTest: false,
                            depthWrite: false
                        });
                        
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(x, y, z);
                        sprite.scale.set(spriteSize, spriteSize, 1);
                        
                        points.add(sprite);
                        sprites.push(sprite);
                    }
                    
                    scene.add(points);
                    
                    loadedModels.push({
                        points: points,
                        sprites: [...sprites],
                        geometry: geometry
                    });
                    currentModelIndex = loadedModels.length - 1;
                    
                    // Pokaż nawigację jeśli jest więcej niż jeden model
                    updateNavigation();
                    
                    loading.classList.remove('show');
                } catch (error) {
                    console.error('Błąd parsowania STL:', error);
                    loading.textContent = 'Błąd ładowania pliku';
                    setTimeout(() => loading.classList.remove('show'), 2000);
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        // Event listeners
        function setupEventListeners() {
            // Drag to rotate
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                } else {
                    // Raycasting dla interakcji z symbolami
                    handleMouseMove(e);
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Touch events
            let touchStartDistance = 0;
            let touchStartRotation = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartRotation = { x: targetRotationX, y: targetRotationY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const scaleChange = distance / touchStartDistance;
                    zoom *= scaleChange;
                    touchStartDistance = distance;
                }
            });
            
            renderer.domElement.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            // Zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom += e.deltaY * -0.001;
                zoom = Math.max(0.5, Math.min(3, zoom));
            });
            
            // Drop file
            renderer.domElement.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            renderer.domElement.addEventListener('drop', (e) => {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files);
                files.forEach(file => {
                    if (file.name.toLowerCase().endsWith('.stl')) {
                        loadSTL(file);
                    }
                });
            });
            
            // Click to load file (tylko gdy nie ma modeli)
            renderer.domElement.addEventListener('click', (e) => {
                // Nie otwieraj dialogu jeśli użytkownik właśnie przeciągał
                if (isDragging) {
                    return;
                }
                
                // Otwórz dialog tylko jeśli nie ma załadowanych modeli
                if (loadedModels.length === 0) {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.stl';
                    input.multiple = true; // Pozwól na wybór wielu plików
                    input.onchange = (e) => {
                        const files = Array.from(e.target.files);
                        files.forEach(file => {
                            if (file.name.toLowerCase().endsWith('.stl')) {
                                loadSTL(file);
                            }
                        });
                    };
                    input.click();
                }
            });
            
            // Resize
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });
            
            // Nawigacja między modelami
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (currentModelIndex > 0) {
                        goToModel(currentModelIndex - 1);
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (currentModelIndex < loadedModels.length - 1) {
                        goToModel(currentModelIndex + 1);
                    }
                });
            }
            
            // Nawigacja klawiaturowa
            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' && currentModelIndex > 0) {
                    goToModel(currentModelIndex - 1);
                } else if (e.key === 'ArrowRight' && currentModelIndex < loadedModels.length - 1) {
                    goToModel(currentModelIndex + 1);
                }
            });
        }

        // Obsługa ruchu myszki dla interakcji ze sprites
        function handleMouseMove(e) {
            if (!raycaster || !points || sprites.length === 0) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // Sprawdź kolizje ze sprites
            const intersects = raycaster.intersectObjects(sprites, false);
            
            // Reset poprzednio podświetlonego sprite'a
            if (hoveredSprite && hoveredSprite !== (intersects[0]?.object || null)) {
                resetSprite(hoveredSprite);
                hoveredSprite = null;
            }
            
            // Podświetl nowy sprite
            if (intersects.length > 0) {
                const intersectedSprite = intersects[0].object;
                if (intersectedSprite !== hoveredSprite) {
                    hoveredSprite = intersectedSprite;
                    highlightSprite(intersectedSprite);
                }
            }
        }
        
        // Podświetl sprite przy najechaniu
        function highlightSprite(sprite) {
            // Zwiększ rozmiar
            const originalScale = sprite.scale.x;
            sprite.userData.originalScale = originalScale;
            sprite.scale.set(originalScale * 1.5, originalScale * 1.5, 1);
            
            // Zwiększ przezroczystość
            sprite.material.opacity = 1.0;
            
            // Zmień symbol na losowy z losowym kolorem
            const newSymbol = getRandomSymbol();
            const newTexture = getSymbolTexture(newSymbol);
            sprite.material.map = newTexture;
            sprite.material.needsUpdate = true;
        }
        
        // Reset sprite'a
        function resetSprite(sprite) {
            if (sprite.userData.originalScale) {
                sprite.scale.set(sprite.userData.originalScale, sprite.userData.originalScale, 1);
            }
            sprite.material.opacity = 0.7;
        }
        
        // Funkcja do aktualizacji nawigacji
        function updateNavigation() {
            const navigation = document.getElementById('navigation');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const navCounter = document.getElementById('navCounter');
            
            if (loadedModels.length > 1) {
                navigation.style.display = 'flex';
            } else {
                navigation.style.display = 'none';
            }
            
            if (prevBtn && nextBtn && navCounter) {
                prevBtn.disabled = currentModelIndex === 0;
                nextBtn.disabled = currentModelIndex === loadedModels.length - 1;
                navCounter.textContent = `${currentModelIndex + 1} / ${loadedModels.length}`;
            }
        }
        
        // Przełącz między modelami
        function goToModel(index) {
            if (index < 0 || index >= loadedModels.length || index === currentModelIndex) return;
            
            // Ukryj aktualny model
            if (points) {
                scene.remove(points);
            }
            
            // Pokaż nowy model
            currentModelIndex = index;
            const model = loadedModels[index];
            points = model.points;
            sprites = model.sprites;
            scene.add(points);
            
            updateNavigation();
        }
        
        // Animacja – kolysanie + wiatr
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            const t = ((typeof performance !== 'undefined' ? performance.now() : Date.now()) - animStart) / 1000;
            
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;
            
            if (points) {
                points.rotation.x = currentRotationX + Math.sin(t * 0.25) * 0.02;
                points.rotation.y = currentRotationY + Math.cos(t * 0.3) * 0.02;
                points.rotation.z = Math.sin(t * 0.4) * 0.04;
                
                points.position.x = Math.sin(t * 0.4) * 0.28;
                points.position.y = Math.sin(t * 0.32 + 0.5) * 0.08;
                
                // lookAt co 2. klatkę – mniej obciążenia CPU
                if (frameCount % 2 === 0) {
                    sprites.forEach(sprite => sprite.lookAt(camera.position));
                }
            }
            
            camera.position.z = 5 / zoom;
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
